<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
    <link rel="stylesheet" href="css/common.css">

    <title>Media Layers</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r121/three.min.js"
      integrity="sha512-yNJzAsg5JyP91u+sLHlUDULMBd3hmEiVkYeeN1cQBKaLZ7EyT6oH2u5THNIRM2Fu6VKcZJv+F/QAp1h/qzy9Ow=="
      crossorigin="anonymous"></script>
  </head>
  <body>
    <header>
      <details open>
        <summary>Media Layers</summary>
        <p>
          Demonstrates using the Media Layers API to create a high-quality video player inside of an "immersive-vr" session.
          <a class="back" href="./">Back</a>
        </p>
        <label>Choose the media"s layout:</label>
        <select id="layoutselect">
          <option value="./media/video/60fps.mp4">
            mono
          </option>
          <option value="./media/video/bbb-sunflower-540p2-1min.webm">
            stereo-top-bottom
          </option>
        </select>
        <p>Trigger = Squeeze = play / pause the video</p>
      </details>
    </header>
    <main style="text-align: center;">
      <p>Click "Enter VR" to see content</p>
    </main>
    <script type="module">
      import { XRControllerModelFactory } from "https://unpkg.com/three/examples/jsm/webxr/XRControllerModelFactory.js";
      import { XRHandModelFactory } from "https://unpkg.com/three/examples/jsm/webxr/XRHandModelFactory.js";
      import { OrbitControls } from "https://unpkg.com/three/examples/jsm/controls/OrbitControls.js";
      import { WebXRButton } from "./js/util/webxr-button.js";
      import { QueryArgs } from "./js/util/query-args.js";

      // This library matches XRInputSource profiles to available controller models for us.
      import { fetchProfile } from "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/motion-controllers@1.0/dist/motion-controllers.module.js";
      import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/loaders/GLTFLoader.js";

      // The path of the CDN the sample will fetch controller models from.
      const DEFAULT_PROFILES_PATH = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles";

      // If requested, use the polyfill to provide support for mobile devices
      // and devices which only support WebVR.
      import WebXRPolyfill from "./js/third-party/webxr-polyfill/build/webxr-polyfill.module.js";
      if (QueryArgs.getBool("usePolyfill", true)) {
        let polyfill = new WebXRPolyfill();
      }

      let xrButton = null;
      const RANGE = 2.75;
      const SPRITE_SCALE = 550;

      let refSpace = null;
      let session = null;

      let layoutSelect = null;
      let threeXrProjector = null;
      let mediaPlayer = null;

      function initXR() {
        xrButton = new WebXRButton({ onRequestSession, onEndSession });
        document.querySelector("header").appendChild(xrButton.domElement);

        if (navigator.xr) {
          navigator.xr.isSessionSupported("immersive-vr").then(supported => {
            xrButton.enabled = supported;
          });
        }
      }

      function onRequestSession() {
        navigator.xr.requestSession("immersive-vr", {
          requiredFeatures: ["layers", "local-floor"],
        }).then(session => {
          xrButton.setSession(session);
          initializeSession(session);
        });
      }

      async function initializeSession(session) {
        layoutSelect = document.getElementById("layoutselect");
        const { text, value } = layoutSelect.options[layoutSelect.selectedIndex];
        
        mediaPlayer = new MediaPlayer(text, value);
        threeXrProjector = new ThreeXRProjector();
        threeXrProjector.useProfileControllerMeshes(session);
        
        await threeXrProjector.initializeXRBindings(session);
        await mediaPlayer.initializeXRBindings(session);
        startSession(session);
      }

      async function startSession(session) {
        session.requestReferenceSpace("local-floor")
          .then(async (referenceSpace) => {
            refSpace = referenceSpace;
            const [equirectMediaLayer] = await mediaPlayer.createEquirectLayer(refSpace);
            const [quadMediaLayer, quadWebGlLayer] = await mediaPlayer.createQuadLayer(refSpace);
            const [threeProjectionLayer] = await threeXrProjector.createProjectionLayer();

            session.addEventListener("squeeze", evt => {
              if (mediaPlayer.isPlaying) mediaPlayer.video.pause();
              else mediaPlayer.video.play();
            });

            session.addEventListener("select", evt => {
              if (mediaPlayer.isPlaying) mediaPlayer.video.pause();
              else mediaPlayer.video.play();
            });

            const layers = [equirectMediaLayer, quadMediaLayer, quadWebGlLayer, threeProjectionLayer];
            session.updateRenderState({ layers });
            
            session.requestAnimationFrame(onAnimationFrame);
            mediaPlayer.video.play();
          });
      }

      function onAnimationFrame(time, frame) {        
        const pose = frame.getViewerPose(refSpace);
        if (!pose) return;

        mediaPlayer.render(frame);
        threeXrProjector.render(frame, pose);
        frame.session.requestAnimationFrame(onAnimationFrame);
      }

      function onEndSession(session) {
        xrButton.setSession(null);
        renderer = null;
      }

      class ThreeXRProjector {
        constructor() {
          this._renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
          });

          this._xrWebGlBinding = null;
          this._projectionWebGlLayer = null;
          this._controllerMeshes = {};

          const gl = this._renderer.getContext();
          this._renderer.setPixelRatio(window.devicePixelRatio);
          this._renderer.setSize(window.innerWidth, window.innerHeight, false);
          this._renderer.outputEncoding = THREE.sRGBEncoding;
          this._renderer.shadowMap.enabled = true;
          this._renderer.xr.enabled = true;
          this._renderer.autoClear = false;

          this._scene = new THREE.Scene();
          this._scene.matrixAutoUpdate = false;

          this._framebuffer = gl.createFramebuffer();
          this._camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);
          this._camera.matrixAutoUpdate = false;
          this._camera.position.set(0, 1.6, 3);

          this._controlsContainer = document.createElement("div");
          this._controls = new OrbitControls(this._camera, this._controlsContainer);
          this._controls.target.set(0, 1.6, 0);
          this._controls.update();

          const lights = this._createLights();
          lights.map(light => this._scene.add(light));
          this._scene.add(this._camera);
        }

        _createLights() {
          const hemisphereLight = new THREE.HemisphereLight(0x808080, 0x606060);
          const directionalLight = new THREE.DirectionalLight(0xffffff);
          directionalLight.position.set(0, 6, 0);
          directionalLight.castShadow = true;
          directionalLight.shadow.camera.top = 2;
          directionalLight.shadow.camera.bottom = - 2;
          directionalLight.shadow.camera.right = 2;
          directionalLight.shadow.camera.left = - 2;
          directionalLight.shadow.mapSize.set(4096, 4096);
          
          return [hemisphereLight, directionalLight];
        }

        async initializeXRBindings(session) {
          const gl = this._renderer.getContext();
          await gl.makeXRCompatible();

          this._xrMediaBinding = new XRMediaBinding(session);
          this._xrWebGlBinding = new XRWebGLBinding(session, gl);
          this._controlsContainer.appendChild(this._renderer.domElement);
          document.body.appendChild(this._controlsContainer);
        }

        async createProjectionLayer() {
          this._projectionWebGlLayer = this._xrWebGlBinding.createProjectionLayer({});
          return [this._projectionWebGlLayer];
        }

        useProfileControllerMeshes(session) {
          const controllers = this._controllerMeshes;
          const scene = this._scene;

          session.addEventListener("inputsourceschange", event => {
            for (let inputSource of event.added) {
              if (inputSource.targetRayMode === "tracked-pointer") {
                fetchProfile(inputSource, DEFAULT_PROFILES_PATH).then(({ profile, assetPath }) => {
                  new GLTFLoader().load(assetPath,
                    function (gltf) {
                      controllers[`${inputSource.targetRayMode}-${inputSource.handedness}`] = gltf.scene;
                      const lineGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, -2.5, 0)]);
                      const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                      const line = new THREE.Line(lineGeometry, lineMaterial);

                      gltf.scene.add(line);
                      gltf.scene.visible = true;
                      gltf.scene.matrixAutoUpdate = false;
                      scene.add(gltf.scene);
                    },
                    function (xhr) {
                      console.log((xhr.loaded / xhr.total * 100) + "% loaded");
                    },
                    function (err) {
                      console.log("An error happened", err);
                    });
                });
              }
            }
          });
        }

        render(frame, pose) {
          if (!pose) return;
          this._renderer.clear();
          const gl = this._renderer.getContext();

          for (let inputSource of frame.session.inputSources) {
            const inputPose = frame.getPose(inputSource.gripSpace, refSpace);
            const { targetRayMode, handedness } = inputSource;

            const controller = this._controllerMeshes[`${targetRayMode}-${handedness}`];
            if (!inputPose || !controller) continue;

            const grip = new THREE.Matrix4();
            grip.fromArray(inputPose.transform.matrix);
            controller.matrix.copy(grip);
          }

          for (let view of pose.views) {
            const viewSubImage = this._xrWebGlBinding.getViewSubImage(this._projectionWebGlLayer, view);
            const viewport = viewSubImage.viewport;

            gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, viewSubImage.colorTexture, 0);
            if (viewSubImage.depthStencilTexture !== undefined) {
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, viewSubImage.depthStencilTexture, 0);
            }

            this._camera.matrix.fromArray(view.transform.matrix);
            this._camera.projectionMatrix.fromArray(view.projectionMatrix);
            this._scene.updateMatrixWorld(true);

            this._renderer.setViewport(viewport.x, viewport.y, viewport.width, viewport.height);
            this._renderer.setFramebuffer(this._framebuffer);

            this._renderer.render(this._scene, this._camera);
            this._renderer.clearDepth();
          }
        }
      }

      class MediaPlayer {
        constructor(layerType, videoSrc) {
          this._renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
          });

          this._renderer.xr.enabled = true;
          this._renderer.setSize(1280, 105);

          this._xrMediaBinding = null;
          this._xrWebGlBinding = null;
          this._quadWebGlLayer = null;
          this._quadMediaLayer = null;
          this._equirectMediaLayer = null;

          this._layoutType = layerType;
          this._videoSrc = videoSrc;
          this._video = null;
          this._timeoutId = null;
          this._isPlaying = false;
          this._showingProgressBar = false;

          this._scene = new THREE.Scene();
          this._camera = new THREE.OrthographicCamera(0, innerWidth * 2, 0, innerHeight * -2);
          this._camera.position.z = 1;

          const gl = this._renderer.getContext();
          const spriteBackground = MediaPlayer.createCube(0xffffff, { x: 168.6, y: -457.5, opacity: 0.75 });
          this._playSprite = MediaPlayer.createSprite("./media/textures/play-button.png", { x: 168.6, y: -457.5 });
          this._pauseSprite = MediaPlayer.createSprite("./media/textures/pause-button.png", { x: 168.6, y: -457.5 });

          this._scene.add(spriteBackground);
          this._scene.add(this._pauseSprite);
          this._scene.add(this._playSprite);
          this._scene.add(this._camera);

          this._framebuffer = gl.createFramebuffer();
          this._readFramebuffer = gl.createFramebuffer();
        }

        get video() { return this._video; }
        get showingProgressBar() { return this._showingProgressBar; }
        get isPlaying() { return this._isPlaying; }

        _determinePlayPauseVisibility() {
          this._playSprite.visible = false;
          this._pauseSprite.visible = false;

          if (this._showingProgressBar) {
            if (this._isPlaying) this._pauseSprite.visible = true;
            else this._playSprite.visible = true;
          }
        }

        _initializeVideoElement() {
          const video = document.createElement("video");
          video.src = this._videoSrc;
          video.loop = true;
          video.volume = 1;

          video.addEventListener("play", () => {
            this.showProgressBar();
            this._isPlaying = true;
          });

          video.addEventListener("pause", () => {
            this.showProgressBar();
            this._isPlaying = false;
          });

          return new Promise(resolve => {
            video.addEventListener("loadeddata", () => {
              return resolve(video);
            });
          });
        }

        async initializeXRBindings(session) {
          const gl = this._renderer.getContext();
          this._video = await this._initializeVideoElement();
          document.body.appendChild(gl.canvas);
          await gl.makeXRCompatible();

          this._xrMediaBinding = new XRMediaBinding(session);
          this._xrWebGlBinding = new XRWebGLBinding(session, gl);
        }

        async createQuadLayer(refSpace, { hideToolbar } = {}) {
          this._quadMediaLayer = this._xrMediaBinding.createQuadLayer(this._video, {
            space: refSpace.getOffsetReferenceSpace(new XRRigidTransform({ x: 0.0, y: 0.0, z: 0.0, w: 1.0 })),
            transform: new XRRigidTransform({ x: 0.0, y: 1.3, z: -RANGE, w: 1.0 }),
            layout: this._layoutType,
          });

          if (!hideToolbar) {
            this._quadWebGlLayer = this._xrWebGlBinding.createQuadLayer({
              layout: "mono",
              space: refSpace.getOffsetReferenceSpace(new XRRigidTransform({ x: 0.0, y: 0.0, z: 0.0, w: 1.0 })),
              transform: new XRRigidTransform({ x: 0.0, y: 0.8175, z: -RANGE, w: 1.0 }),
              viewPixelHeight: 105,
              viewPixelWidth: 1280,
              height: 105 / 1280,
              width: 1,
            });
          }

          return [this._quadMediaLayer, this._quadWebGlLayer];
        }

        async createEquirectLayer(refSpace) {
          this._equirectMediaLayer = this._xrMediaBinding.createEquirectLayer(this._video, { space: refSpace });
          return [this._equirectMediaLayer];
        }

        hideProgressBar() {
          this._showingProgressBar = false;
          this._renderer.setClearColor(0x000000, 0);
          for (let child of this._scene.children) { 
            child.visible = false;
          }
        }

        showProgressBar() {
          this._showingProgressBar = true;
          this._renderer.setClearColor(0x000000, 0.75);
          for (let child of this._scene.children) { 
            child.visible = true;
          }
          
          if (this._timeoutId) clearTimeout(this._timeoutId);
          this._timeoutId = setTimeout(this.hideProgressBar.bind(this), 4000);
        }

        render(frame) {
          const gl = this._renderer.getContext();
          const glSubImage = this._xrWebGlBinding.getSubImage(this._quadWebGlLayer, frame);
          this._determinePlayPauseVisibility();

          gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glSubImage.colorTexture, 0);
          gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._readFramebuffer);

          this._renderer.render(this._scene, this._camera);
        }

        static createCube(color, { x, y, z, opacity }) {
          const geometry = new THREE.BoxGeometry(1, 1, 1);
          const material = new THREE.MeshBasicMaterial({ color, opacity });
          const cube = new THREE.Mesh(geometry, material);

          cube.scale.x = 650 / 7;
          cube.scale.y = 650;

          cube.position.x = x || 0;
          cube.position.y = y || 0;
          cube.position.z = z || 0;

          return cube;
        }

        static createSprite(resourceUrl, { x, y, z }) {
          const spriteMap = new THREE.TextureLoader().load(resourceUrl);
          const spriteMaterial = new THREE.SpriteMaterial({ map: spriteMap });
          const sprite = new THREE.Sprite(spriteMaterial);

          sprite.scale.x = SPRITE_SCALE / 7;
          sprite.scale.y = SPRITE_SCALE;
          sprite.scale.z = SPRITE_SCALE;

          sprite.position.x = x || 0;
          sprite.position.y = y || 0;
          sprite.position.z = z || 0;

          return sprite;
        } 
      }

      // Start the XR application.
      initXR();
    </script>
  </body>
</html>
