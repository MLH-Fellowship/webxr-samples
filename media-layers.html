<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
    <link rel="stylesheet" href="css/common.css">

    <title>Media Layers</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r121/three.min.js"
      integrity="sha512-yNJzAsg5JyP91u+sLHlUDULMBd3hmEiVkYeeN1cQBKaLZ7EyT6oH2u5THNIRM2Fu6VKcZJv+F/QAp1h/qzy9Ow=="
      crossorigin="anonymous"></script>
  </head>
  <body>
    <header>
      <details open>
        <summary>Media Layers</summary>
        <p>
          Demonstrates using the Media Layers API to create a high-quality video player inside of an "immersive-vr" session.
          <a class="back" href="./">Back</a>
        </p>
        <label>Choose the media"s layout:</label>
        <select id="layoutselect">
          <option value="./media/video/60fps.mp4">
            mono
          </option>
          <option value="./media/video/bbb-sunflower-540p2-1min.webm">
            stereo-top-bottom
          </option>
        </select>
        <p>Trigger = Squeeze = play / pause the video</p>
      </details>
    </header>
    <main style="text-align: center;">
      <p>Click "Enter VR" to see content</p>
    </main>
    <script type="module">
      import { XRControllerModelFactory } from "https://unpkg.com/three/examples/jsm/webxr/XRControllerModelFactory.js";
      import { XRHandModelFactory } from "https://unpkg.com/three/examples/jsm/webxr/XRHandModelFactory.js";
      import { OrbitControls } from "https://unpkg.com/three/examples/jsm/controls/OrbitControls.js";
      import { WebXRButton } from "./js/util/webxr-button.js";
      import { QueryArgs } from "./js/util/query-args.js";

      // This library matches XRInputSource profiles to available controller models for us.
      import { fetchProfile } from "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/motion-controllers@1.0/dist/motion-controllers.module.js";
      import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/loaders/GLTFLoader.js";

      // The path of the CDN the sample will fetch controller models from.
      const DEFAULT_PROFILES_PATH = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles";

      // If requested, use the polyfill to provide support for mobile devices
      // and devices which only support WebVR.
      import WebXRPolyfill from "./js/third-party/webxr-polyfill/build/webxr-polyfill.module.js";
      if (QueryArgs.getBool("usePolyfill", true)) {
        let polyfill = new WebXRPolyfill();
      }

      let xrButton = null;
      let refSpace = null;
      let session = null;

      let layoutSelect = null;
      let threeXrProjector = null;
      let mediaPlayer = null;

      function initXR() {
        xrButton = new WebXRButton({ onRequestSession, onEndSession });
        document.querySelector("header").appendChild(xrButton.domElement);

        if (navigator.xr) {
          navigator.xr.isSessionSupported("immersive-vr").then(supported => {
            xrButton.enabled = supported;
          });
        }
      }

      function onRequestSession() {
        navigator.xr.requestSession("immersive-vr", {
          requiredFeatures: ["layers", "local-floor"],
        }).then(session => {
          xrButton.setSession(session);
          initializeSession(session);
        });
      }

      async function initializeSession(session) {
        layoutSelect = document.getElementById("layoutselect");
        const { text, value } = layoutSelect.options[layoutSelect.selectedIndex];
        
        mediaPlayer = new MediaPlayer(text, value);
        threeXrProjector = new ThreeXRProjector();
        threeXrProjector.useProfileControllerMeshes(session);
        
        await threeXrProjector.initializeXRBindings(session);
        await mediaPlayer.initializeXRBindings(session);
        startSession(session);
      }

      async function startSession(session) {
        session.requestReferenceSpace("local-floor")
          .then(async (referenceSpace) => {
            refSpace = referenceSpace;
            const [equirectMediaLayer] = await mediaPlayer.createEquirectLayer(refSpace);
            const [quadMediaLayer, quadWebGlLayer] = await mediaPlayer.createQuadLayer(refSpace);
            const [threeProjectionLayer] = await threeXrProjector.createProjectionLayer();
            threeXrProjector.makeRigidTransformLayerPressable(quadWebGlLayer);

            const layers = [equirectMediaLayer, quadMediaLayer, quadWebGlLayer, threeProjectionLayer];
            const handleControllerPress = (evt) => {
              if (!mediaPlayer.showingProgressBar) mediaPlayer.showProgressBar();
              mediaPlayer._onPress(evt);
            };

            session.addEventListener("squeeze", handleControllerPress);
            session.addEventListener("select", handleControllerPress);

            session.updateRenderState({ layers });
            session.requestAnimationFrame(onAnimationFrame);
            mediaPlayer.video.play();
          });
      }

      function onAnimationFrame(time, frame) {        
        const pose = frame.getViewerPose(refSpace);
        if (!pose) return;

        mediaPlayer.render(frame);
        threeXrProjector.render(frame, pose);
        frame.session.requestAnimationFrame(onAnimationFrame);
      }

      function onEndSession(session) {
        xrButton.setSession(null);
        renderer = null;
      }

      class ThreeXRProjector {
        constructor() {
          this._renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
          });

          this._xrWebGlBinding = null;
          this._projectionWebGlLayer = null;
          this._controllerMeshes = {};

          const gl = this._renderer.getContext();
          this._renderer.setPixelRatio(window.devicePixelRatio);
          this._renderer.setSize(window.innerWidth, window.innerHeight, false);
          this._renderer.outputEncoding = THREE.sRGBEncoding;
          this._renderer.shadowMap.enabled = true;
          this._renderer.xr.enabled = true;
          this._renderer.autoClear = false;

          this._scene = new THREE.Scene();
          this._scene.matrixAutoUpdate = false;

          this._framebuffer = gl.createFramebuffer();
          this._camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);
          this._camera.matrixAutoUpdate = false;
          this._camera.position.set(0, 1.6, 3);

          this._controlsContainer = document.createElement("div");
          this._controls = new OrbitControls(this._camera, this._controlsContainer);
          this._controls.target.set(0, 1.6, 0);
          this._controls.update();

          const lights = this._createLights();
          lights.map(light => this._scene.add(light));
          this._scene.add(this._camera);
        }

        _createLights() {
          const hemisphereLight = new THREE.HemisphereLight(0x808080, 0x606060);
          const directionalLight = new THREE.DirectionalLight(0xffffff);
          directionalLight.position.set(0, 6, 0);
          directionalLight.castShadow = true;
          directionalLight.shadow.camera.top = 2;
          directionalLight.shadow.camera.bottom = - 2;
          directionalLight.shadow.camera.right = 2;
          directionalLight.shadow.camera.left = - 2;
          directionalLight.shadow.mapSize.set(4096, 4096);
          
          return [hemisphereLight, directionalLight];
        }

        async initializeXRBindings(session) {
          const gl = this._renderer.getContext();
          await gl.makeXRCompatible();

          this._xrMediaBinding = new XRMediaBinding(session);
          this._xrWebGlBinding = new XRWebGLBinding(session, gl);
          this._controlsContainer.appendChild(this._renderer.domElement);
          document.body.appendChild(this._controlsContainer);
        }

        async createProjectionLayer() {
          this._projectionWebGlLayer = this._xrWebGlBinding.createProjectionLayer({});
          return [this._projectionWebGlLayer];
        }

        makeRigidTransformLayerPressable(layer) {
          const geometry = new THREE.PlaneGeometry(layer.width * 2, layer.height * 2);
          const material = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide, opacity: 0 });
          const mirror = new THREE.Mesh(geometry, material);

          mirror.name = "mirror";
          mirror.position.x = layer.transform.position.x;
          mirror.position.y = layer.transform.position.y;
          mirror.position.z = layer.transform.position.z * 23/22;
          this._scene.add(mirror);
        }

        useProfileControllerMeshes(session) {
          const controllers = this._controllerMeshes;
          const scene = this._scene;

          session.addEventListener("inputsourceschange", event => {
            for (let inputSource of event.added) {
              if (inputSource.targetRayMode === "tracked-pointer") {
                fetchProfile(inputSource, DEFAULT_PROFILES_PATH).then(({ profile, assetPath }) => {
                  new GLTFLoader().load(assetPath,
                    function (gltf) {
                      controllers[`${inputSource.targetRayMode}-${inputSource.handedness}`] = gltf.scene;

                      const controller = gltf.scene.children[0];
                      const controllerCenter = new THREE.Box3().setFromObject(controller).getCenter(controller.position);
                      const lineGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, -1.25, 0)]);
                      const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                      const line = new THREE.Line(lineGeometry, lineMaterial);
                      line.position.copy(controllerCenter);

                      const cursorGeometry = new THREE.CircleGeometry(0.05, 30);
                      const cursorMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 1, side: THREE.DoubleSide });
                      const cursor = new THREE.Mesh(cursorGeometry, cursorMaterial);
                      cursor.scale.x = 0.25;
                      cursor.scale.y = 0.25;
                      cursor.scale.z = 0.25;

                      gltf.scene.visible = true;
                      gltf.scene.matrixAutoUpdate = false;
                      gltf.scene._cursor = cursor;
                      gltf.scene._line = line;
                      gltf.scene.add(line);

                      scene.add(gltf.scene);
                      scene.add(cursor);
                    },
                    function (xhr) {
                      console.log((xhr.loaded / xhr.total * 100) + "% loaded");
                    },
                    function (err) {
                      console.log("An error happened", err);
                    });
                });
              }
            }
          });
        }

        render(frame, pose) {
          if (!pose) return;
          this._renderer.clear();
          const gl = this._renderer.getContext();

          for (let inputSource of frame.session.inputSources) {
            const inputPose = frame.getPose(inputSource.gripSpace, refSpace);
            const { targetRayMode, handedness } = inputSource;

            const controller = this._controllerMeshes[`${targetRayMode}-${handedness}`];
            if (!inputPose || !controller) continue;

            const grip = new THREE.Matrix4();
            grip.fromArray(inputPose.transform.matrix);
            controller.matrix.copy(grip);

            const laserLength = -2.5;
            const rayMatrix = new THREE.Matrix4();
            const rayMatrixWorld = new THREE.Matrix4();
            rayMatrix.fromArray(inputPose.transform.matrix);

            const raycaster = new THREE.Raycaster();
            const raycasterOrigin = new THREE.Vector3();
            const raycasterDestination = new THREE.Vector3(0, laserLength, 0);

            rayMatrixWorld.multiplyMatrices(this._scene.matrixWorld, rayMatrix);
            raycasterOrigin.setFromMatrixPosition(rayMatrixWorld);
            raycaster.set(raycasterOrigin, raycasterDestination.transformDirection(rayMatrixWorld).normalize());

            let intersects = raycaster.intersectObjects(this._scene.children, true);
            let foundIntersection = false;

            for (let intersect of intersects) {
              if (intersect && intersect.object && !intersect.object.name.includes("mirror")) {
                mediaPlayer._onRaycasterDidIntersect(null, null);
                continue;
              };

              foundIntersection = true;
              const shouldShowCursor = mediaPlayer._onRaycasterDidIntersect(intersect.point.x, intersect.point.y);

              controller._cursor.visible = shouldShowCursor;
              controller._cursor.position.copy(intersect.point);
              controller._cursor.position.z += 0.1;
              break;
            }

            if (!foundIntersection) controller._cursor.visible = false;
          }

          for (let view of pose.views) {
            const viewSubImage = this._xrWebGlBinding.getViewSubImage(this._projectionWebGlLayer, view);
            const viewport = viewSubImage.viewport;

            gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, viewSubImage.colorTexture, 0);
            if (viewSubImage.depthStencilTexture !== undefined) {
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, viewSubImage.depthStencilTexture, 0);
            }

            this._camera.matrix.fromArray(view.transform.matrix);
            this._camera.projectionMatrix.fromArray(view.projectionMatrix);
            this._scene.updateMatrixWorld(true);

            this._renderer.setViewport(viewport.x, viewport.y, viewport.width, viewport.height);
            this._renderer.setFramebuffer(this._framebuffer);

            this._renderer.render(this._scene, this._camera);
            this._renderer.clearDepth();
          }
        }
      }

      class Button {
        constructor(x, y, spriteUrl, scene, { spriteScale, backgroundScale, invertColor, backgroundColor, backgroundOpacity }) {
          const spriteMaterial = new THREE.SpriteMaterial({ map: new THREE.TextureLoader().load(spriteUrl) });
          this._sprite = new THREE.Sprite(spriteMaterial);

          if (spriteScale) {
            this._sprite.scale.x = spriteScale;
            this._sprite.scale.y = spriteScale;
          }

          this._sprite.position.x = x;
          this._sprite.position.y = y;
          this._sprite._resource = spriteUrl;

          this._invertMaterial = new THREE.MeshBasicMaterial({ color: invertColor || 0x000000, opacity: backgroundOpacity || 1.0 });
          this._backgroundMaterial = new THREE.MeshBasicMaterial({ color: backgroundColor || 0x000000, opacity: backgroundOpacity || 1.0 });
          this._background = new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.0, 1.0), this._backgroundMaterial);
          this._onPress = undefined;

          if (backgroundScale) {
            this._background.scale.x = backgroundScale;
            this._background.scale.y = backgroundScale;
          }

          this._background.position.x = x;
          this._background.position.y = y;

          scene.add(this._background);
          scene.add(this._sprite);
        }

        get visible() { return this._background.visible; }
        get position() { return this._background.position; }
        get scale() { return this._background.scale; }

        set visible(isVisible) {
          this._background.visible = isVisible;
          this._sprite.visible = isVisible;
        }

        showInverse() { this._background.material = this._invertMaterial; }
        hideInverse() { this._background.material = this._backgroundMaterial; }
      }

      class MediaPlayer {
        constructor(layerType, videoSrc) {
          this._renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
          });

          this._renderer.xr.enabled = true;
          this._renderer.setSize(1280, 105);

          this._xrMediaBinding = null;
          this._xrWebGlBinding = null;

          this._quadWebGlLayer = null;
          this._quadMediaLayer = null;
          this._equirectMediaLayer = null;

          this._layoutType = layerType;
          this._videoSrc = videoSrc;
          this._video = null;

          this._lastX = null;
          this._lastY = null;
          this._timeoutId = null;

          this._showingProgressBar = false;
          this._isPlaying = false;
          this._isMuted = false;

          this._camera = new THREE.OrthographicCamera(0, 1280, 0, -105);
          this._camera.position.z = 1;

          this._scene = new THREE.Scene();
          this._scene.add(this._camera);

          const buttonOptions = {
            invertColor: 0x4fb5ff,
            backgroundColor: 0xffffff,
            backgroundOpacity: 0.75,
            backgroundScale: 75,
            spriteScale: 65
          };

          this._backwardButton = new Button(1280 / 10, -105 / 2, "./media/textures/backward-button.png", this._scene, buttonOptions);

          this._playButton = new Button(1280 / 10 * 2, -105 / 2, "./media/textures/play-solid.png", this._scene, buttonOptions);
          this._pauseButton = new Button(1280 / 10 * 2, -105 / 2, "./media/textures/pause-solid.png", this._scene, buttonOptions);

          this._forwardButton = new Button(1280 / 10 * 3, -105 / 2, "./media/textures/forward-button.png", this._scene, buttonOptions);

          this._muteButton = new Button(1280 / 10 * 7, -105 / 2, "./media/textures/volume-mute-button.png", this._scene, buttonOptions);
          this._unmuteButton = new Button(1280 / 10 * 7, -105 / 2, "./media/textures/volume-off-button.png", this._scene, buttonOptions);

          this._volumeDownButton = new Button(1280 / 10 * 8, -105 / 2, "./media/textures/volume-down-button.png", this._scene, buttonOptions);
          this._volumeUpButton = new Button(1280 / 10 * 9, -105 / 2, "./media/textures/volume-up-button.png", this._scene, buttonOptions);

          this._buttons = [this._backwardButton, this._playButton, this._pauseButton, this._forwardButton, this._muteButton, this._unmuteButton, this._volumeUpButton, this._volumeDownButton];

          const gl = this._renderer.getContext();
          this._framebuffer = gl.createFramebuffer();
          this._readFramebuffer = gl.createFramebuffer();
        }

        get video() { return this._video; }
        get showingProgressBar() { return this._showingProgressBar; }
        get isPlaying() { return this._isPlaying; }

        _initializeVideoElement() {
          const video = document.createElement("video");
          video.src = this._videoSrc;
          video.loop = true;
          video.volume = 1;

          video.addEventListener("play", () => {
            this.showProgressBar();
            this._isPlaying = true;
          });

          video.addEventListener("pause", () => {
            this.showProgressBar();
            this._isPlaying = false;
          });

          return new Promise(resolve => {
            video.addEventListener("loadeddata", () => {
              return resolve(video);
            });
          });
        }

        _timeoutProgressBar() {
          if (this._timeoutId) clearTimeout(this._timeoutId);
          this._timeoutId = setTimeout(this.hideProgressBar.bind(this), 4000);
        }

        _determineToggleButtonVisibility() {
          this._playButton.visible = false;
          this._pauseButton.visible = false;
          this._unmuteButton.visible = false;
          this._muteButton.visible = false;

          if (this._showingProgressBar) {
            if (this._isPlaying) this._pauseButton.visible = true;
            else this._playButton.visible = true;

            if (this._isMuted) this._unmuteButton.visible = true;
            else this._muteButton.visible = true;
          }
        }

        _getButtonsInBound(x, y) {
          return this._buttons.filter(button => {
            const isInBoundsX = x >= button.position.x - button.scale.x / 2 && x <= button.position.x + button.scale.x / 2;
            const isInBoundsY = y >= button.position.y - button.scale.y / 2 && y <= button.position.y + button.scale.y / 2;
            return button.visible && isInBoundsX && isInBoundsY;
          });
        }

        _onPress(evt) {
          this._getButtonsInBound(this._lastX, this._lastY).forEach(button => button._onPress());
        }

        _onRaycasterDidIntersect(worldX, worldY) {          
          this._lastX = worldX ? (worldX + 1) / (1 * 2 / 1280) + 4 : -9999;
          this._lastY = worldY ? (worldY - 0.08203125) / (0.08203125 * 2 / 105) - 518 : -9999;

          for (let button of this._buttons) { button.hideInverse(); }
          if (!worldX || !worldY || !this.showingProgressBar) return false;

          this._getButtonsInBound(this._lastX, this._lastY).forEach(button => button.showInverse());
          this._timeoutProgressBar();
          return true;
        }

        async initializeXRBindings(session) {
          const gl = this._renderer.getContext();
          document.body.appendChild(gl.canvas);

          await gl.makeXRCompatible();
          this._xrMediaBinding = new XRMediaBinding(session);
          this._xrWebGlBinding = new XRWebGLBinding(session, gl);
          this._video = await this._initializeVideoElement();

          this._backwardButton._onPress = () => this._video.currentTime = String(Math.max(0, this._video.currentTime - 10));
          this._forwardButton._onPress = () => this._video.currentTime = String(Math.min(this._video.duration, this._video.currentTime + 10));
          this._volumeUpButton._onPress = () => this._video.volume = Math.min(1, this._video.volume + 0.1);
          this._volumeDownButton._onPress = () => this._video.volume = Math.max(0, this._video.volume - 0.1);

          this._pauseButton._onPress = () => {
            if (this._isPlaying) this._video.pause();
          }
          this._playButton._onPress = () => {
            if (!this._isPlaying) this._video.play();
          }
          this._muteButton._onPress = () => {
            if (!this._isMuted) {
              this._video.muted = true;
              this._isMuted = true;
            }
          }
          this._unmuteButton._onPress = () => {
            if (this._isMuted) {
              this._video.muted = false;
              this._isMuted = false;
            }
          }          
        }

        async createQuadLayer(refSpace, { hideToolbar } = {}) {
          this._quadMediaLayer = this._xrMediaBinding.createQuadLayer(this._video, {
            space: refSpace.getOffsetReferenceSpace(new XRRigidTransform({ x: 0.0, y: 0.0, z: 0.0, w: 1.0 })),
            transform: new XRRigidTransform({ x: 0.0, y: 1.3, z: -2.75, w: 1.0 }),
            layout: this._layoutType,
          });

          if (!hideToolbar) {
            this._quadWebGlLayer = this._xrWebGlBinding.createQuadLayer({
              layout: "mono",
              space: refSpace.getOffsetReferenceSpace(new XRRigidTransform({ x: 0.0, y: 0.0, z: 0.0, w: 1.0 })),
              transform: new XRRigidTransform({ x: 0.0, y: 0.8175, z: -2.75, w: 1.0 }),
              viewPixelHeight: 105,
              viewPixelWidth: 1280,
              height: 105 / 1280,
              width: 1,
            });
          }

          return [this._quadMediaLayer, this._quadWebGlLayer];
        }

        async createEquirectLayer(refSpace) {
          this._equirectMediaLayer = this._xrMediaBinding.createEquirectLayer(this._video, { space: refSpace });
          return [this._equirectMediaLayer];
        }

        hideProgressBar() {
          this._showingProgressBar = false;
          this._renderer.setClearColor(0x000000, 0);
          for (let child of this._scene.children) { 
            child.visible = false;
          }
        }

        showProgressBar() {
          this._showingProgressBar = true;
          this._renderer.setClearColor(0x000000, 0.75);
          for (let child of this._scene.children) { 
            child.visible = true;
          }

          this._timeoutProgressBar();
        }

        render(frame) {
          const gl = this._renderer.getContext();
          const glSubImage = this._xrWebGlBinding.getSubImage(this._quadWebGlLayer, frame);
          this._determineToggleButtonVisibility();

          gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glSubImage.colorTexture, 0);
          gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._readFramebuffer);

          this._renderer.render(this._scene, this._camera);
        }
      }

      // Start the XR application.
      initXR();
    </script>
  </body>
</html>
